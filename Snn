import numpy as np
import pandas as pd
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from sklearn import svm
from sklearn import metrics
import matplotlib.pyplot as plt
import seaborn as sns
import itertools

# Input value encoding: Gaussian receptive field
gauss_neuron = 12  # Each input value is encoded by 12 gaussian neurons
center = np.ones((gauss_neuron, 1))		
width = 1/15
# let the value range equal in each feautres, thus gaussian encoding center for each feature is the same
for i in range(len(center)): # let f_max=1, f_min=0. Center for each feature=i/(n - 1)
  center[i] = (2*i-3)/20  # Center of gaussian shift from left to right

x = np.arange(0, 1, 0.0001) # input variable resolution in gaussian receptive field
num_features = 2
gauss_recpt_field = np.zeros((gauss_neuron, len(x))) # gaussian receptive field for input stimulate response
spike_time = np.zeros((gauss_neuron, num_features)) # 24 gaussian encoding neurons for 2 input features
# Define gaussian receptive field for input variables entries
for i in range(gauss_neuron):
  gauss_recpt_field[i, :] = np.exp( -(x-center[i])**2/(2*width*width) ) # different shift for each gaussian function

def gauss_response(inputs):
  for i in range(num_features):
    # for each input[i]
    for j in range(gauss_neuron):
      spike_time[j, i] = gauss_recpt_field[j, inputs[i]] # input feature enter the gaussian entry, recieve response
  spikes = []
  for i in range(spike_time.shape[1]):
    spikes.extend(spike_time[:, i])
  return np.array(spikes)	

# uploas the input signals to model 
import pandas as pd
from google.colab import files
up=files.upload()
for fn in up.keys():
  print('User up files "{name}" with length {length} bytes'.format (
   name=fn, length=len(up[fn])))
  import io
data=pd.read_csv(io.StringIO(up['AX_1.csv'].decode('utf-8')))
#data.tail()
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
#print(data1.head(5))
X=data.iloc[:, 1:3].values
y=data.iloc[:, 0].values
labelencoder_X_1=LabelEncoder()
y=labelencoder_X_1.fit_transform(y)

# encoding of input signals 
gauss_neurons = gauss_neuron*num_features
scaler = MinMaxScaler()
X = scaler.fit_transform(X)

# There are 10000 entries in each gaussian function
X = (X*10000).astype(int) # meet the index of gaussian receptive field, drop the fourth decimal
X[X == 10000] = 9999 # convert all input value indexing to gaussian matrix entry
input_spike = np.zeros((X.shape[0], gauss_neurons)) # spike time in [0, 1]

for i in range(X.shape[0]):
  input_spike[i, :] = gauss_response(X[i, :])
input_spike[input_spike < 0.1] = 0  # set activate value < 0.1 to zero
input_spike = np.around(100*(1 - input_spike)) # convert actiate value to 0~100 timing, round the decimals
#Adjust t = 0 firing to t = 1
input_spike[input_spike == 0] = 1
x_train, x_valid, y_train, y_valid = train_test_split(input_spike, y, test_size = 0.1, stratify = y)
#y_train, y_valid = y_train.values, y_valid.values
# Start training
def heavyside(t, t_i):
  if (t - t_i) >= 0:
    return 1
  elif (t - t_i) < 0:
    return 0
def K_res(t, t_i):
  time = np.arange(0, 101, 1)
  tou_m = 15
  tou_s = tou_m/4
  V_0 = (np.exp(-(time)/tou_m) - np.exp(-(time)/tou_s)).max()  #normalization factor: divide the K() response by maximum value
  response = ( np.exp(-(t-t_i)/tou_m) - np.exp(-(t-t_i)/tou_s) )*heavyside(t, t_i)/V_0
  return response

#Model parameters
iterations = 20
num_class = 2
V = np.zeros((num_class, 100)) # potential of each output neuron
V_rest = 0
weight = np.random.random((gauss_neurons, num_class)) # connections btw input neuron and output neuron(here use single synaptic for simplicity)
threshold = 1 # set threshold: try and error
T = 100    # time encoding window
firing_time = np.zeros((gauss_neurons)) # time-to-first-spike for all gaussian neurons
Response = np.zeros((gauss_neurons))  # K(t-t_i) response for each gaussian neurons
lr = 0.005
tou_m = 15
time = np.arange(1, T+1)
accuracy = np.zeros((iterations))
